## 加载

加载：就是把二进制形式的java类型读入到java虚拟机中

​		类的加载的最终产品是位于内存中的Class对象

​		Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内数据结构的接口

### 类加载器

有两种类型的类加载器

​	java虚拟机自带的加载器

​		根类加载器Bootstrap

​		扩展类加载器Extension

​		系统（应用）类加载器System

​	用户自定义类加载器

​		java.lang.ClassLoader的子类

​		用户可以定制类的加载方式

类加载器并不需要等到某个类被“首次主动使用”时再加载它

- jvm规范允许类加载器在预料某个类将要被使用时就预先加载它，如果预先加载的过程遇到.class文件缺失或者存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误） 
- 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误

类加载器：类加载器用来把类加载到java虚拟机中。从jdk1.2版本开始，类加载过程采用父类委托机制，这种机制能更好地保证java平台的安全（保证一份字节码只会存在一份）。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父类加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。 

java虚拟机自带以下几种类加载器：

- 根（Bootstrap）类加载器：该加载器没有父类加载器。它负责加载虚拟机的核心类库，如：java.lang.*等。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。

  由c++实现，不是ClassLoder子类

- 扩展（Extension）类加载器：它的父加载器为根类加载器，它从java.ext.dirs系统属性所指定的目录中加载类库（只加载jar文件，*.class文件不加载），如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。

  

- 系统（System）类加载器，也称为应用类加载器，它的父类加载器作为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，它是由用户自定义的类加载器的默认父加载器。系统类加载器是纯java类，是java.lang.ClassLoader类的子类

- 除以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。java提供类抽象类java.lang.ClassLoader,所有用户自定义的类加载器都应该继承ClassLoader类 

#### 类加载器的父类委托机制

​	在父类委托机制中，各个类加载器按照父子关系形成了树形结构，除了根类加载器之外，其余的类加载器都有且只有一个父加载器。  

​	自定义加载器2-》自定义类加载器1->系统类加载器-〉扩展类加载器-》根类加载器-〉

【图片】

​	若有一个类加载器能够成功加载类A,那么这个类加载器被称为定义类加载器，所有能够成功返回Class对象引用的类加载器（包括定义类加载器）都被称为初始类加载器。

​	类加载器并不需要等到某个类被“首次主动使用”时再加载它

​	需要指出的是，加载器之间的父子关系实际上指的是加载器对象之间的包装关系，而不是类之间的继承关系。一对父子类加载器可能是同一个加载器类的两个实例，也可能不是。在子加载器对象中包装了一个父加载器对象。例如以下 loader1和loader2都是MyClassLoader类的实例，并且loader2包装了loader1,loader1是loader2的父加载器



#### 获取ClassLoader的途径

```java
//获取当前类的ClassLoader
clazz.getClassLoader();
//获取当前线程上下文的ClassLoader
Thread.currentThread().getContextClassLoader();
//获取系统的ClassLoader();
ClassLoader.getSystemClassLoader();
//获取调用者的ClassLoader
DriverManager.getCallerClassLoader();
```

jar hell问题以及解决办法

当一个类或者一个资源文件存在多个jar中，就会存在jar hell问题。

可以通过以下代码来诊断问题：

```java
ClassLoader classLoader = Thread.currentThread.getContextClassLoader();
String resourceName = "java/lang/String.class";
Enumeration<URL> urls = classLoader.getResource(resourceName);
while(urls.hasMoreElements()){
  URL url = urls.nextElement();
  System.out.println(url);
}
```



#### 命令空间

​	每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。

​	在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类

​	在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类

同一个命名空间内的类是互相可见的。

子加载器的命名空间包含所有父加载器的命名空间。因此子加载器加载的类能看见父加载器加载的类。例如系统类加载器加载的类能看见根类加载器加载的类。

由父加载器加载的类不能看见子加载器加载的类，。

如果两个加载器之间没有直接或间接的父子关系，那么他们各自加载器的类相互不可见。

#### 创建自己的类加载器

扩展java.lang.ClassLoader类，覆盖findClass(String name)即可。

## 验证

验证：

​		准备：为类变量分配内存、设置默认值。但是在到达初始化之前，类变量都没有初始化为真正的初始值。

​		解析：解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程  

​		初始化：为类型变量赋正确的初始值

类被加载后，就进入连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。

### 准备

​	在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0.

```java
public class Sample{
  private static int a = 1;
  private static long b;
  static{
    b = 2;
  }
  ...
}
```

### 初始化

​	在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：

1. 在静态变量的声明处进行初始化
2. 在静态变量的代码块中进行初始化

例如以下代码，静态变量a和b都被显式初始化，而静态变量c没有被显式初始化，c将保持默认值0

```java
public class Sample{
  private static int a = 1;//静态变量声明处进行初始化
  private static int b;
  private static long c;
  static{
    b = 2;//在静态代码块中进行初始化
  }
  ...
}
```

​	静态变量的声明语句，以及静态代码块都被看作类的初始化语句。java虚拟机会按照初始化语句在类文件中先后顺序来依次执行它们。例如当以下Sample类被初始化后，它的静态变量a的取值为4

```java
public class Sample{
  private static int a = 1;/
  static{
    a = 2;
  }
  static{
    a = 4;
  }
  public static void main(String args[]){
    System.out.println("a="+a);
  }
}
```

类的初始化步骤：

- 假如这个类还没有被加载和连接，那就先执行加载和连接
- 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
- 假如类中存在初始化语句，那就依次执行这些初始化语句

类的初始化时机：

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（如：Class.forName("com.sty.类路径")）
- 初始化一个类的子类
- java虚拟机启动时被标明为启动类的类
- jdk1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化。

除以上几种情况，其它使用java类的方式都被看作是被动使用，不会导致类的初始化。

​	当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适应于接口。

​		1.在初始化一个类时，并不会先初始化它所实现的接口。

​		2 在初始化一个接口时，并不会先初始化它的父接口。

​		因此，一个接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。

只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。 

调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

​	





类实例化：

​			为新的对象分配内存

​			为实例变量赋于默认值

​			为实例变量赋正确的初始值

​			java编译期为它编译的每一个类都至少生成一个实例化初始化方法，在java的class文件中，这个实例初始化方法被称为<init>,针对源代码中每个一类的构造方法，java编译器都会产生一个<init>方法



## 类的卸载

​	当一个类被加载、连接和初始化后，它的生命周期就开始了，当代表类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载，从而结束类的生命周期。  

​	一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。

​	由java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因为这些Class对象始终是可触及的。

​	由用户自定义的类加载器所加载的类是可以被卸载的。  

​	自定义类加载器加载一个类时，在类加载器内部，用一个java集合来存放所有加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表一个类的Class实例与自定义类加载器之间为双向关联关系。

​	一个类的实例总是引用代表这个类的Class对象。在Object类中定义类getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的java类都有一个静态属性class,它引用代表这个类的Class对象