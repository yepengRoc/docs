原文地址：https://www.oracle.com/technical-resources/articles/java/g1gc.html

# Garbage First Garbage Collector Tuning

了解有关如何调整和调整G1 GC以进行评估，分析和性能的信息

Garbage First Garbage Collector（G1 GC）是Java HotSpot VM的低中断，服务器风格的世代垃圾收集器。G1 GC使用并发和并行阶段来实现其目标暂停时间并保持良好的吞吐量。当G1 GC确定需要进行垃圾收集时，它将首先收集活动数据最少的区域（首先是垃圾）。

垃圾收集器（GC）是一种内存管理工具。G1 GC通过以下操作实现自动内存管理：

- 将对象分配给年轻一代，并将老化的对象提升为老一代
- 通过并发（并行）标记阶段查找旧一代中的活动对象。当Java堆总占用量超过默认阈值时，Java HotSpot VM会触发标记阶段。
- 通过并行复制压缩活动对象来恢复可用内存。

在这里，我们研究如何适应和调整G1 GC以进行评估，分析和性能-我们假定对Java垃圾收集有基本的了解

G1 GC是一个区域化的，按代划分的垃圾收集器，这意味着Java对象堆（堆）被划分为多个大小相等的区域。启动时，Java虚拟机（JVM）设置区域大小。区域大小可以从1 MB到32 MB不等，具体取决于堆大小。目标是不超过2048个区域。伊甸园，幸存者和前几代人是这些区域的逻辑集合，并不相邻。

G1 GC具有尝试达到的暂停时间目标（软实时）。在年轻系列中，G1 GC会调整其年轻一代（伊甸园和幸存者的大小），以达到柔和的实时目标。在混合收集期间，G1 GC根据混合垃圾收集的目标数量，堆中每个区域中的活动对象的百分比以及总体可接受的堆废物百分比来调整收集的旧区域的数量。

G1 GC通过将活动对象从一个或多个区域集（称为集合集（CSet））递增并行复制到不同的新区域中来实现压缩，从而减少了堆碎片。目标是从包含最大可回收空间的那些区域开始，尽可能多地回收堆空间，同时尝试不超过暂停时间目标（首先是垃圾）。

G1 GC使用独立的记忆集（RSets）来将引用跟踪到区域中。独立的RSets可以并行和独立地收集区域，因为只有区域的RSet必须被扫描以查找对该区域的引用，而不是整个堆。G1 GC使用写后屏障来记录对堆的更改并更新RSets。

## 垃圾收集阶段

除了组成世界末日（STW）年轻和混合垃圾收集的疏散暂停（如下所述）之外，G1 GC还具有并行，并发和多阶段标记周期。G1 GC使用快照快照（SATB）算法，该算法在标记周期开始时对堆中活动对象的集合进行快照。活动对象集由快照中的活动对象以及自标记周期开始以来分配的对象组成。G1 GC标记算法使用预写屏障来记录和标记属于逻辑快照的对象。

## 年轻代垃圾收集器

G1 GC满足了来自添加到eden区域集中的区域的大多数分配请求。在年轻的垃圾收集期间，G1 GC从先前的垃圾收集中收集了伊甸园地区和幸存者地区。来自伊甸园地区和幸存者地区的活物被复制或撤离到一组新的地区。特定对象的目标区域取决于对象的年龄。经过充分老化的物体可以疏散到旧区域（即被提升）；否则，该对象将撤离到幸存者区域，并将包含在下一个年轻垃圾或混合垃圾收集的CSet中。

## 混合垃圾收集

成功完成并发标记循环后，G1 GC从执行年轻垃圾收集切换为执行混合垃圾收集。在混合垃圾收集中，G1 GC可以选择将一些旧区域添加到将要收集的伊甸园区域和幸存者区域中。添加的旧区域的确切数量由许多标志控制，这些标志将在后面讨论（请参阅“为混合GC命名”）。在G1 GC收集到足够数量的旧区域（通过多个混合垃圾收集）之后，G1恢复为执行年轻垃圾收集，直到下一个标记周期完成

## 标记周期的各个阶段

标记周期分为以下几个阶段：

- 初始标记阶段：G1 GC在此阶段标记根。此阶段由常规（STW）年轻垃圾回收支持。
- 根区域扫描阶段：G1 GC扫描初始标记的幸存者区域，以获取对旧一代的引用，并标记所引用的对象。该阶段与应用程序（非STW）同时运行，并且必须在下一个STW年轻垃圾收集开始之前完成。
- 并发标记阶段：G1 GC在整个堆中找到可访问的（活动的）对象。此阶段与应用程序同时发生，并且可以被STW年轻的垃圾回收中断。
- 从新 标记阶段：此阶段是STW收集，有助于完成标记周期。G1 GC耗尽SATB缓冲区，跟踪未访问的活动对象，并执行参考处理。
- 清理阶段：在最后阶段，G1 GC执行计费和RSet清理的STW操作。在记帐期间，G1 GC会识别出完全空闲的区域和混合垃圾收集候选对象。当它重置并将空区域返回到空闲列表时，清理阶段部分并发。

## 重要的默认值

G1 GC是具有默认设置的自适应垃圾收集器，可使其无需修改即可高效工作。这是重要选项及其默认值的列表。该列表适用于最新的Java HotSpot VM（版本24）。您可以通过在JVM命令行上输入以下选项并更改设置来适应和调整G1 GC以满足应用程序的性能需求。

- -XX：G1HeapRegionSize = n

  设置G1区域的大小。该值为2的幂，范围为1MB至32MB。目标是根据最小Java堆大小具有大约2048个区域。

- -XX：MaxGCPauseMillis = 200为所需的最大暂停时间设置目标值。默认值为200毫秒。指定的值不适合您的堆大小。
- -XX：G1NewSizePercent = 5设置要用作年轻代大小的最小值的堆百分比。默认值为Java堆的5％。这是一个实验性标志。有关示例，请参见“如何解锁实验性VM标志”。此设置替换
- -XX：DefaultMinNewGenPercent设置。此设置在Java HotSpot VM（内部版本23）中不可用。
- -XX：G1MaxNewSizePercent = 60设置堆大小的百分比，以用作年轻代大小的最大值。默认值为Java堆的60％。这是一个实验性标志。有关示例，请参见“如何解锁实验性VM标志”。此设置替换-XX：DefaultMaxNewGenPercent设置。此设置在Java HotSpot VM（内部版本23）中不可用。
- -XX：ParallelGCThreads = n设置STW工作线程的值。将n的值设置为逻辑处理器的数量。n的值与最多等于8的逻辑处理器的数量相同。如果逻辑处理器多于八个，则将n的值设置为逻辑处理器的大约5/8。除较大的SPARC系统外，这在大多数情况下都有效，其中n的值约为逻辑处理器的5/16。
- -XX：ConcGCThreads = n设置平行标记线的数量。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4。
- -XX：InitiatingHeapOccupancyPercent = 45设置触发标记周期的Java堆占用阈值。默认占用率为整个Java堆的45％。
- -XX：G1MixedGCLiveThresholdPercent = 65设置要包含在混合垃圾收集周期中的旧区域的占用阈值。默认占用率为65％。这是一个实验性标志。有关示例，请参见“如何解锁实验性VM标志”。此设置替换-XX：G1OldCSetRegionLiveThresholdPercent设置。此设置在Java HotSpot VM（内部版本23）中不可用。
- -XX：G1HeapWastePercent = 10设置您愿意浪费的堆百分比。当可回收百分比小于堆垃圾百分比时，Java HotSpot VM不会启动混合垃圾回收周期。默认值为10％。此设置在Java HotSpot VM（内部版本23）中不可用。
- -XX：G1MixedGCCountTarget = 8设置标记周期后混合垃圾回收的目标数量，以收集具有最多G1MixedGCLIveThresholdPercent个实时数据的旧区域。默认值为8个混合垃圾回收。混合馆藏的目标是在此目标数量之内。此设置在Java HotSpot VM（内部版本23）中不可用。
- -XX：G1OldCSetRegionThresholdPercent = 10设置在混合垃圾收集周期中要收集的旧区域数的上限。缺省值为Java堆的10％。此设置在Java HotSpot VM（内部版本23）中不可用。
- -XX：G1ReservePercent = 10设置保留内存的百分比以保持可用，以减少空间溢出的风险。默认值为10％。当增加或减少百分比时，请确保将总Java堆调整为相同的数量。此设置在Java HotSpot VM（内部版本23）中不可用。

## 如何解锁实验性VM标志

要更改实验性标志的值，您必须先将其解锁。您可以通过在任何实验性标志之前在命令行上显式设置-XX：+ UnlockExperimentalVMOptions来执行此操作。例如：

```
java -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=10 -XX:G1MaxNewSizePercent=75 G1test.jar
```

## 推荐建议

在评估和微调G1 GC时，请牢记以下建议：

- 年轻代大小：避免使用-Xmn选项或任何其他相关选项（例如-XX：NewRatio）显式设置年轻代大小。固定年轻一代的大小会覆盖目标暂停时间目标。
- 暂停时间目标：当您评估或调整任何垃圾收集时，总会有延迟与吞吐量的权衡。G1 GC是具有统一暂停的增量垃圾收集器，但在应用程序线程上也有更多开销。G1 GC的吞吐量目标是90％的应用时间和10％的垃圾收集时间。当您将其与Java HotSpot VM的吞吐量收集器进行比较时，目标是99％的应用程序时间和1％的垃圾收集时间。因此，在评估G1 GC的吞吐量时，请放宽暂停时间目标。设定过于激进的目标表示您愿意承担垃圾收集开销的增加，这直接影响了吞吐量。在评估G1 GC的延迟时，您可以设置所需的（软）实时目标，G1 GC会尝试实现它。副作用是，吞吐量可能会受到影响。
- 驯服混合垃圾收集：调整混合垃圾收集时，请尝试以下选项。有关这些选项的信息，请参见“重要默认值”：-XX：正在启动堆占用率用于更改标记阈值。
  - -XX：正在启动堆占用率用于更改标记阈值。
  - -XX：G1MixedGCLiveThresholdPercent和-XX：G1HeapWastePercent当您要更改混合垃圾收集决策时。
  - -XX：G1MixedGCCountTarget和-XX：G1OldCSetRegionThresholdPercent当您想为旧区域调整CSet时。

## 溢出和耗尽日志消息

当您在日志中看到空间上的溢出/耗尽消息时，G1 GC没有足够的内存来存储幸存者或升级对象，或两者都没有。Java堆无法扩展，因为它已经达到了最大值。消息示例：

```
924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space exhausted), 0.1957310 secs]
```

或者

```
924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space overflow), 0.1957310 secs]
```

要缓解此问题，请尝试以下调整：

增加-XX：G1ReservePercent选项的值（并相应增加总堆），以增加“至空间”的保留内存量。

通过减少-XX：InitiatingHeapOccupancyPercent来更早地开始标记周期。

您还可以增加-XX：ConcGCThreads选项的值，以增加并行标记线程的数量。

有关这些选项的说明，请参见“重要默认值”。

## Humongous Objects and Humongous Allocations

对于G1 GC，任何大于区域大小一半的对象都被视为“巨大对象”。这样的对象在上一代中直接分配到“大型区域”中。这些巨大的区域是一组连续的区域。StartsHumongous标志着连续集合的开始，ContinuesHumongous标志着集合的继续。

在分配任何巨型区域之前，请检查标记阈值，并在必要时启动并发循环。

在清理阶段以及整个垃圾收集周期的标记周期结束时，将释放死掉的巨大物体。

为了减少复制开销，任何疏散暂停均不包括Humongous对象。完整的垃圾收集周期将庞大的对象压缩到位。

由于StartsHumongous和ContinuesHumongous区域的每个单独集合仅包含一个humongous对象，因此未使用humongous对象的末端与该对象所覆盖的最后一个区域的末端之间的空间。对于刚好大于堆区域大小倍数的对象，未使用的空间可能导致堆碎片化。

如果您看到由于Humongous分配而启动的背对背并发周期，并且这种分配使您的上一代分裂了，请增加-XX：G1HeapRegionSize，使先前的Humongous对象不再是Humongous对象，并且将遵循常规分配路径。